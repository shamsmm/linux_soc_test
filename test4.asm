# RISC-V Assembly to test CSR registers
# Tests mstatus, mtvec, mcause, mip, mie
# Generated by: Claude (Anthropic)

.text
.globl _start

_start:
    # Initialize registers with test patterns
    li x1, 0xDEADBEEF
    li x2, 0x12345678
    li x3, 0xABCDEF00
    li x4, 0x55AA55AA
    li x5, 0xFF00FF00

    # ========================================
    # Test MSTATUS (0x300)
    # ========================================
    li x10, 0x1888        # MIE=1, MPIE=1, MPP=11 (Machine mode)
    csrw mstatus, x10      # Write to mstatus
    csrr x11, mstatus      # Read back mstatus
    
    # Test individual bit manipulation
    csrsi mstatus, 0x8     # Set MIE bit (bit 3)
    csrr x12, mstatus      # Read after set
    
    csrci mstatus, 0x8     # Clear MIE bit
    csrr x13, mstatus      # Read after clear

    # ========================================
    # Test MTVEC (0x305) 
    # ========================================
    li x20, 0x1000         # Base address 0x1000, MODE=00 (Direct)
    csrw mtvec, x20        # Write to mtvec
    csrr x21, mtvec        # Read back mtvec
    
    li x20, 0x2001         # Base address 0x2000, MODE=01 (Vectored)
    csrw mtvec, x20        # Write vectored mode
    csrr x22, mtvec        # Read back

    # ========================================
    # Test MIE (0x304) - Machine Interrupt Enable
    # ========================================
    li x30, 0x888          # Enable MEIE, MTIE, MSIE (bits 11,7,3)
    csrw mie, x30          # Write to mie
    csrr x31, mie          # Read back mie
    
    # Test bit manipulation
    li x1, 0x80            # Load bit 7 mask into register
    csrs mie, x1           # Set MTIE (bit 7) using register
    csrr x6, mie           # Read after set
    
    csrci mie, 0x8         # Clear MSIE (bit 3)
    csrr x7, mie           # Read after clear

    # ========================================
    # Test MIP (0x344) - Machine Interrupt Pending
    # Note: MIP bits are typically read-only or set by hardware
    # ========================================
    csrr x8, mip           # Read current mip value
    
    # Try to write (may be ignored depending on implementation)
    li x9, 0x888
    csrw mip, x9           # Attempt write
    csrr x8, mip           # Read back to see what changed

    # ========================================
    # Test MCAUSE (0x342)
    # ========================================
    li x15, 0x8000000B     # Interrupt=1, Exception Code=11 (Machine external interrupt)
    csrw mcause, x15       # Write to mcause
    csrr x16, mcause       # Read back mcause
    
    li x15, 0x00000002     # Interrupt=0, Exception Code=2 (Illegal instruction)
    csrw mcause, x15       # Write exception cause
    csrr x17, mcause       # Read back

    # ========================================
    # Combined CSR operations test
    # ========================================
    # Save current state
    csrr x25, mstatus
    csrr x26, mie
    
    # Modify multiple CSRs
    li x1, 0x1800          # New mstatus value
    li x2, 0xAAA           # New mie value
    csrw mstatus, x1
    csrw mie, x2
    
    # Read all CSRs in sequence for waveform analysis
    csrr x27, mstatus      # Should show new value
    csrr x28, mtvec        # Should show previous value
    csrr x29, mcause       # Should show previous value
    csrr x18, mie          # Should show new value
    csrr x19, mip          # Read current mip

    # ========================================
    # Stress test - rapid CSR access
    # ========================================
    li x3, 0x1000
    csrw mtvec, x3
    csrr x4, mtvec
    csrw mstatus, x3
    csrr x5, mstatus
    csrw mie, x3
    csrr x6, mie

    # ========================================
    # Test edge cases
    # ========================================
    # Write all 1s to see which bits are implemented
    li x1, 0xFFFFFFFF
    csrw mstatus, x1
    csrr x2, mstatus       # Check which bits are writable
    
    csrw mtvec, x1
    csrr x3, mtvec         # Check mtvec bit mask
    
    csrw mie, x1
    csrr x4, mie           # Check mie bit mask

    # Write all 0s
    li x1, 0x00000000
    csrw mstatus, x1
    csrr x5, mstatus       # Check reset behavior
    
    csrw mtvec, x1
    csrr x6, mtvec
    
    csrw mie, x1
    csrr x7, mie

    # Final state read for verification
    csrr x10, mstatus
    csrr x11, mtvec
    csrr x12, mcause
    csrr x13, mie
    csrr x14, mip

    # ========================================
    # End with NOPs to flush pipeline
    # ========================================
    nop
    nop
    nop
    nop

# Infinite loop to prevent invalid instruction fetch
halt:
    j halt

.end