# Generated by Gemini 2.5 Flash

.section .text
.global _start

# --- Memory Map and Register Offsets (SiFive FE310 compatible) ---
# GPIO Base Address
.equ GPIO_BASE,         0x30000000
.equ GPIO_OUTPUT_EN,    (GPIO_BASE + 0x08)  # Register to enable output for pins
.equ GPIO_OUTPUT_VAL,   (GPIO_BASE + 0x0C)  # Register to set/get pin output value

# CLIC Base Address
.equ CLIC_BASE,         0xE0000000
.equ MTIMECMP,          (CLIC_BASE + 0x02004000) # Machine Timer Compare Register
.equ MTIME,             (CLIC_BASE + 0x0200BFF8) # Machine Timer Register

# LED is connected to Pin 7
.equ LED_PIN,           7
.equ LED_PIN_MASK,      (1 << LED_PIN) # Bitmask for LED_PIN (0b10000000)

# Timer Interrupt Interval
# Assuming a 50MHz clock, 25,000,000 cycles for 500ms delay
.equ TIMER_INTERVAL,    3375000 # Adjust this value based on your actual clock speed and desired delay


# --- Main Entry Point ---
_start:
    # Initialize stack pointer (adjust as needed for your specific memory layout)
    # For simulation, a simple high address can work.
    la sp, _stack_top

    # Configure GPIO for LED
    call init_gpio

    # Initialize and configure the Machine Timer
    call init_timer

    # Enable global interrupts (MIE bit in mstatus)
    # MIE is bit 3 in mstatus (0b1000)
    li t0, 0x8
    csrrs x0, mstatus, t0 # Set MIE bit in mstatus (mstatus = mstatus | 0x8)

    # Enter an infinite loop, waiting for interrupts
    # 'wfi' (Wait For Interrupt) will put the CPU into a low-power state
    # until an interrupt occurs.
main_loop:
    wfi
    j main_loop


# --- GPIO Initialization Function ---
# Configures LED_PIN as output and sets its initial state to OFF (low)
init_gpio:
    # Load GPIO_OUTPUT_EN address into a0
    la a0, GPIO_OUTPUT_EN
    # Read current value of GPIO_OUTPUT_EN
    lw t0, 0(a0)
    # Set the LED_PIN_MASK bit (bit 7) to enable output for pin 7
    ori t0, t0, LED_PIN_MASK
    # Write the new value back to GPIO_OUTPUT_EN
    sw t0, 0(a0)

    # Load GPIO_OUTPUT_VAL address into a0
    la a0, GPIO_OUTPUT_VAL
    # Read current value of GPIO_OUTPUT_VAL
    lw t0, 0(a0)
    # Clear the LED_PIN_MASK bit (bit 7) to ensure LED is initially OFF (low)
    andi t0, t0, ~LED_PIN_MASK
    # Write the new value back to GPIO_OUTPUT_VAL
    sw t0, 0(a0)

    ret # Return from function


# --- Timer Initialization Function ---
# Configures the Machine Timer Compare (MTIMECMP) and enables the timer interrupt
init_timer:
    # Disable Machine Timer Interrupt (MTIE bit in mie) temporarily
    # MTIE is bit 7 in mie (0b10000000)
    li t0, (1 << 7)
    csrrc x0, mie, t0 # Clear MTIE bit in mie (mie = mie & ~0x80)

    # Read current MTIME value
    la a0, MTIME        # Load MTIME address
    lw t0, 0(a0)        # Read lower 32 bits of MTIME (MTIME is 64-bit, but FE310 often handles 32-bit access for MTIMECMP/MTIME through memory-mapped regs)
                        # For full 64-bit MTIME, would need to read MTIMEH and MTME.
                        # For 32-bit RISC-V, it's common to only use lower 32-bits for MTIMECMP calculation
    # Add the desired interval to current MTIME to get the next compare value
    li t1, TIMER_INTERVAL # Load the large TIMER_INTERVAL into t1
    add t1, t0, t1        # Add current MTIME (t0) to TIMER_INTERVAL (t1), store in t1


    # Write the new compare value to MTIMECMP
    la a0, MTIMECMP     # Load MTIMECMP address
    sw t1, 0(a0)        # Write the new compare value

    # Set Machine Trap-Vector (MTVEC) to point to the timer_isr
    # Set BASE to address of timer_isr, and MODE to 0 (Direct mode)
    la t0, timer_isr    # Load address of timer_isr
    csrrw x0, mtvec, t0 # Set mtvec = timer_isr address

    # Enable Machine Timer Interrupt (MTIE bit in mie)
    li t0, (1 << 7)
    csrrs x0, mie, t0   # Set MTIE bit in mie (mie = mie | 0x80)

    ret # Return from function


# --- Timer Interrupt Service Routine (ISR) ---
# Toggles the LED and schedules the next timer interrupt
timer_isr:
    # Save context: Push required registers onto the stack
    # This is a minimal set for this simple ISR.
    # In a real system, you'd save all caller-saved registers and potentially some callee-saved ones.
    addi sp, sp, -16    # Make space for 4 registers (4 bytes each for RV32I)
    sw ra, 12(sp)       # Save return address (ra)
    sw t0, 8(sp)        # Save temporary register t0
    sw t1, 4(sp)        # Save temporary register t1
    sw t2, 0(sp)        # Save temporary register t2


    # --- LED Toggling Logic ---
    # Load GPIO_OUTPUT_VAL address
    la a0, GPIO_OUTPUT_VAL
    # Read current value of GPIO_OUTPUT_VAL
    lw t0, 0(a0)
    # Toggle the LED_PIN_MASK bit (bit 7)
    xor t0, t0, LED_PIN_MASK
    # Write the new value back to GPIO_OUTPUT_VAL
    sw t0, 0(a0)


    # --- Schedule Next Timer Interrupt ---
    # Read current MTIME value
    la a0, MTIME        # Load MTIME address
    lw t0, 0(a0)        # Read lower 32 bits of MTIME
    # Add the desired interval to current MTIME to get the next compare value
    li t1, TIMER_INTERVAL # Load the large TIMER_INTERVAL into t1
    add t1, t0, t1        # Add current MTIME (t0) to TIMER_INTERVAL (t1), store in t1


    # Write the new compare value to MTIMECMP
    la a0, MTIMECMP     # Load MTIMECMP address
    sw t1, 0(a0)        # Write the new compare value


    # Restore context: Pop saved registers from the stack
    lw t2, 0(sp)        # Restore t2
    lw t1, 4(sp)        # Restore t1
    lw t0, 8(sp)        # Restore t0
    lw ra, 12(sp)       # Restore ra
    addi sp, sp, 16     # Restore stack pointer

    mret # Machine Return from Exception/Interrupt